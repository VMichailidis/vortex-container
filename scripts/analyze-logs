#! /usr/bin/env -S uv run --script
# /// script
# requires-python = ">=3.13"
# dependencies = [
#     "pandas",
# ]
# ///
# uv add --script analyze-logs <package>(== | > | < )<version_number>
 
# TODO: verify parser
# TODO: Write documentation
import argparse
import sys
import pandas as pd
import re

from pathlib import Path as path

def is_scalar(vec: str|None):
    """Checks if a string with the format {a, b, c, d} is sclalar"""
    if vec is None:
        return None
    elems = vec.strip("{}").split(", ")
    return all(elem == elems[0] for elem in elems)

def parse(file: str):
    """Extracts execution data from input and stores them to a dataframe"""
    op_pattern = re.compile(r'''
^DEBUG\sInstr:\s+(?P<instr>\S+)
.*?
cid=(?P<cid>\d),\s*
wid=(?P<wid>\d),\s*
tmask=(?P<tmask>\d+),.*?$
(?:
    \n^DEBUG\s+Src0\s+Reg:\s+x\d+=(?P<src_0>\{.*?\})
)?
(?:
    \n^DEBUG\s+Src1\s+Reg:\s+x\d+=(?P<src_1>\{.*?\})
)?
(?:
    \n^DEBUG\s+Dest\s+Reg:\s+x\d+=(?P<dest>\{.*?\})
)?
''', re.MULTILINE | re.VERBOSE)

    with open("run.log", 'r') as log:
        log_content = log.read()
        ops = [
              m.groupdict()
              for m in op_pattern.finditer(log_content)
        ]
    return pd.DataFrame(ops)


def main(args):
    """Parses the input file and returns the sclarization relevant stats"""
    ops = parse(args["in"])
    ops["scalar_src_0"] = ops["src_0"].apply(is_scalar)
    ops["scalar_src_1"] = ops["src_1"].apply(is_scalar)
    # TODO: calculate the results for src_2
    out = ops[["scalar_src_0"]].value_counts()
    exit("Error on line 61, you have not implemented this correctly")
    src_2 = ops[["scalar_src_0"]].value_counts()
    inst_count = ops.shape[0]
    stat = out.get(True)/(inst_count) * 100
    return out.get(True), inst_count, stat

    # print(ops[["instr", "src_0", "scalar_src_0", "src_1", "scalar_src_0"]].to_string())

if __name__ == "__main__":
    parser = argparse.ArgumentParser()

    parser.add_argument("-i", help="Input File")
    parser.add_argument("-o", help="Output File")
    parser.add_argument(
                        "-c",
                        help="Print Scalarization Candidates",
                        action="store_true"
                        )
    parser.add_argument(
                        "-s",
                        help="Print Instruction Count",
                        action="store_true"
                        )
    parser.add_argument(
                        "-p",
                        help="Print percentage of scalarization candidate",
                        action="store_true"
                        )

    args = parser.parse_args()

    args_n = {}
    if args.i:
        args_n.update({"in": (path.cwd()/args.i).resolve()})
    else:
        print("Error: No input specified", file=sys.stderr)
        exit(-1)
    if args.o:
        args_n.update({"out": (path.cwd()/args.o).resolve()})
    else:
        args_n.update({"out": (path.cwd()/"./out.csv").resolve()})

    scalar, inst, stat = main(args_n)

    if not (args.c or args.s or args.p):
        print(f"out of {inst} executed commands, {stat:.1f}% were candidates for scalarization")
        exit(0)
    out = ""
    if args.c:
        out+=f"{scalar}"
    if args.s:
        out+=f" {inst}"
    if args.p:
        out+=f" {stat:.1f}%"
    print(out.strip())
    
    exit(0)
